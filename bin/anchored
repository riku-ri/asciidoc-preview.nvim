#!/usr/bin/env python

import sys
import re

splitlines = sys.stdin.read().splitlines()

skip = {
	"^:[A-Za-z_]+:" , # probable self-defined variable
	"^\\s*$" , # emptyline
}

last = {
	"^\\+$" , # probable hang block
	"^_{4,}$" # probable quoteed block
}

incode = None

for i,l in enumerate(splitlines) :
	if re.search("^= " , l) : # the book title
		splitlines = splitlines[0:i+1] + ['','pass:[<span/>]',''] + splitlines[i+1:len(splitlines)]
		'''
		In the $(asciidoctor -s) default settings,
		asciidoctor does not show the book titile in content
		anchor to book titile will make a missing anchor
		So here insert a non-empty line but non-content things
		'''
		break
lines = splitlines.copy()
for i,l in enumerate(lines) :
	if False : pass
	elif incode is not None :
		lines[i] = '<'
		if l==incode :
			incode = None
	elif re.search("^\\[" , l) :
		if re.search("\\]$" , l) :
			lines[i] = '<' # the code language line
	elif re.search("^-{4,}$" , l) :
		lines[i] = '<' # don't anchor this line, anchor to the previous
		incode = l
	elif any(map(lambda r:re.search(r , l) , skip)) :
		lines[i] = '<'
	elif any(map(lambda r:re.search(r , l) , last)) :
		lines[i] = '<'
	elif re.search("^$" , l) : # empty line
		lines[i] = '<'
	else :
		lines[i] = None

lastanchor = 0
delay = set()
#^^^ this is to prevent when the line 0 is not true content, such as asciidoc variable :var:
#^^^ the later program can not find where to anchor it
for i,l in enumerate(lines) :
	if False: pass
	elif l==None :
		lines[i] = {i}
		lastanchor = i
		if len(delay)>0 :
			lines[i] = lines[i].union(delay)
			delay = set()
	elif l=='<' :
		if lastanchor==0 :
			delay.add(i)
		else:
			lines[lastanchor].add(i)
		lines[i] = set()
	elif l=='-' :
		lines[lastanchor].add(i)
		lines[i] = set()

##'''
##Currently, anchors in lines[] is match to the line in asciidoc.
##
##Due to the asciidoc syntax,
##to prevent asciidoc parser parse the anchor to true content in page,
##we can add a empty <span/> tag at the tail of the asciidoc line.
##
##But if insert the anchors at the tail,
##when web browser javascript go to the anchor,
##the line is exactly above the view content.
##Because the anchor is at the end of asciidoc line, which means the "next html element"
##
##Hence the later code shift anchor to the location of the previous anchor
##'''
##
##
##lines = list(reversed(lines))
##
##next = set()
##for i,l in enumerate(lines) :
##	if len(l)>0 :
##		lines[i] , next = next , lines[i]
##
##lines = list(reversed(lines))
##for i,l in enumerate(lines) :
##	if len(l)>0 :
##		lines[i] = lines[i].union(next)
##		break

for i,l in enumerate(lines) :
	if len(l)>0 :
		lines[i] = ' pass:[' + ''.join(map(lambda __:f'<span id="al{__}"/>' , l)) + ']'
	else :
		lines[i] = ''

lines = [
	f'{splitlines[i]}{lines[i]}'
	for i in range(len(lines))
]
print('\n'.join(lines))
